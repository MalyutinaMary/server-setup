# Настройка серверов
![image](https://github.com/user-attachments/assets/9e240007-fa74-47b9-9342-ac00ec1b1182)

## Эмулятор
* GNS3

## Оборудование
* Маршрутизатор Cisco 3745

## Статическая маршрутизация

Выделены подсети 10.10.10.0/24, 10.10.20.0/24, 10.10.30.0/24. Сконфигурированы статические маршруты, обеспечивающие соединение между всеми устройствами (это необходимый шаг для выполнения всех последующих заданий).

Команда для конфигурации статического маршрута:
> (config) `ip route <subnet-address> <subnet-mask> <next-hop-ip-address>`

Конфигурация статического маршрута до подсети 10.10.20.0/24 через next-hop 10.10.10.2/24:
> R1#(config) `ip route 10.10.20.0 255.255.255.0 10.10.10.2`

## NTP

С помощью команды `sh clock detail` можно отобразить показания системных часов (system clock) и источник времени. По умолчанию при запуске устройства системные часы синхронизируются с аппаратными (hardware clock). В рамках данного проекта мы работаем с образом, для которого не предусмотрена настройка аппаратных часов, в связи с чем при каждом новом запуске системные часы получают устаревшие показания следующего вида:

![image](https://github.com/user-attachments/assets/1a6fde21-edde-402c-8d6c-77f9affce70a)

Можно задать показания системных часов вручную (но они не запишутся в startup-config и сбросятся при перезагрузке):
>`clock timezone <hours-offset>`
>
>`clock set HH:MM:SS MONTH DAY YEAR`

Альтернативное решение - указать в качестве источника времени NTP-сервер:
>(config) `ntp server <ip-address>`

Адреса реальных NTP-серверов Google можно найти с помощью команды `nslookup time.google.com`, но в этом проекте мы их не используем.

Будем считать, что системные часы R1 не уступают по точности атомным, и назначим их в качестве источника времени для R1:
> R1#(config) `ntp master`

Далее указываем R1 в качестве источника времени для R2: 
> R2#(config) `ntp server 10.10.10.1`

Проверяем статус синхронизации:

![image](https://github.com/user-attachments/assets/55dba27e-8ea3-41c9-a8a5-d5fbf40c22f7)

## DNS

В рамках данного проекта не используются реальные доменные имена и адреса. Доменное имя my.site разрешается в адрес 10.10.11.1, присвоенный loopback-интерфейсу устройства R1. Команды для настройки loopback-интерфейса приведены ниже:

> R1#(config) `int Loopback0`
>
> R1#(config-if) `ip add 10.10.11.1 255.255.255.0`

Далее сконфигурируем R1 как DNS-сервер:
> R1#(config) `ip dns server`

Создадим запись о соответствии доменного имени my.site адресу 10.10.11.1: 
> R1#(config) `ip host my.site 10.10.11.1`

Сконфигурируем R2 как DNS-клиент, указывая адрес DNS-сервера:
> R2#(config) `ip name-server 10.10.10.1`

Разрешим R2 выполнять DNS-запросы:
> R2#(config) `ip domain lookup`

Проверим корректность разрешения доменного имени в адрес:

![image](https://github.com/user-attachments/assets/4480f846-83e9-4107-bce4-67e642e8ccc1)

Отметим, что мы сконфигурировали дополнительный маршрут между подсетями 10.10.10.0/24 и 10.10.11.0/24, поэтому R2 может успешно обмениваться ICMP-пакетами с my.site. Если такой маршрут отсутствует, доменное имя всё равно разрешится в адрес, но ICMP-пакеты не пройдут.

## DHCP

Сконфигурируем R3 как DHCP-сервер, чтобы автоматически выдавать клиентским устройствам IP-адреса, сообщать им адрес DNS-сервера и так далее.

Укажем диапазон адресов, которые НЕЛЬЗЯ выдавать устройствам:
>(config) `ip dhcp excluded-address 10.10.30.1 10.10.30.200`

Создадим пул доступных адресов USER_POOL:
>(config) `ip dhcp pool USER_POOL`

Укажем подсеть, из которой будут выдаваться адреса (кроме адресов в диапазоне excluded):
>(dhcp-config) `network 10.10.30.0 255.255.255.0`

Укажем default gateway:
>(dhcp-config) `default-router 10.10.30.3`

Укажем длительность аренды адресов - 5 часов 30 минут:
>(dhcp-config) `lease 0 5 30`

Укажем адрес DNS-сервера:
>(dhcp-config) `dns-server 10.10.11.1`

На PC1 инициируем процесс DORA, в результате которого PC1 получит в аренду IP-адрес:
![image](https://github.com/user-attachments/assets/fc6488b5-32ee-47de-bffe-19605b858012)

Убедимся, что PC1 теперь знает адрес DNS-сервера:

![image](https://github.com/user-attachments/assets/46c763db-c6b8-4399-9f99-753fe874e502)

## SSH

Настроим возможность удаленного подключения к устройству R1.

Активируем систему AAA, которая позволит настроить параметры аутентификации и авторизации пользователей:
> R1#(config) `aaa new-model`

Создадим пользователя admin:
> R1#(config) `username admin`

Создадим пароль для пользователя admin:
> R1#(config) `username admin secret <admin-password>`

Настроим возможность авторизации для удаленного выполнения команд в режиме privileged:
> R1#(config) `enable secret <privileged-password>`

Этих настроек достаточно, чтобы подключиться к R1 по telnet:

![image](https://github.com/user-attachments/assets/c982993a-51fd-4bca-b910-7656ee1db811)

Но мы хотим пользоваться более безопасным протоколом SSH, поэтому продолжим.

На основе hostname (R1) и domain-name (mynetwork.local) сгенерируем SSH-ключ для шифрования передаваемых данных:
> R1#(config) `ip domain-name mynetwork.local`
> 
> R1#(config) `crypto key generate rsa`

В появившейся строке необходимо будет указать длину ключа не менее 2048 бит.
![image](https://github.com/user-attachments/assets/b2f10bcc-6b97-4c12-b9c1-d2b8897fee75)

Сконфигурируем виртуальные терминалы удаленного доступа так, чтобы разрешать доступ только по SSH:
> R1#(config) `line vty 0 4`
> 
> R1#(config-line) `transport input ssh`

Настроим версию SSH:
> R1#(config) `ip ssh version 2`

Теперь можно подключаться к R1 по SSH и выполнять команды в режиме privileged:

![image](https://github.com/user-attachments/assets/c129cf0c-c1d1-4251-89f4-d5a12aad4728)
